<레디스 1>
1) 레디스의 전반적인 작동 구조
ae.c:aeMain()은 Redis의 이벤트 루프를 구현하는 부분이다. 이벤트 루프란 서버가 클라이언트로부터 메세지를 요청받고 이에 대한 응답을 반환하기 위해 계속해서 이벤트를 대기하는 상태를 유지, 반복하는 프로그래밍 방법론이다. 이 소스코드에서는 파일 디스크립터(유닉스 계열 운영체제에서 프로세스가 특정 파일에 접근할 때 사용하는 추상값)의 변화나 타이머 이벤트등을 감지하고 처리하는 내용이다. 다음은 코드의 주요 함수와 그 기능에 대한 간략한 설명이다

   	1. 이벤트 루프 초기화 및 생성
        - aeCreateEventLoop: 이벤트 루프를 초기화하고 생성. 주어진 크기로 이벤트 구조체를 할당하고 초기화.

    	2. 이벤트 루프 크기 및 속성 변경
        - aeGetSetSize: 현재 이벤트 루프의 크기를 반환.
        - aeSetDontWait: 이벤트 루프의 대기 타임아웃을 변경.

    	3. 파일 이벤트 처리
        - aeCreateFileEvent: 파일 이벤트를 생성하고 등록.
        - aeDeleteFileEvent: 파일 이벤트를 제거.
        - aeGetFileClientData: 파일 이벤트와 관련된 클라이언트 데이터를 반환.
        - aeGetFileEvents: 파일 이벤트의 현재 상태를 반환.

    	4. 타이머 이벤트 처리
        - aeCreateTimeEvent: 타이머 이벤트를 생성하고 등록.
        - aeDeleteTimeEvent: 타이머 이벤트를 제거.
        - usUntilEarliestTimer: 가장 빠르게 발생할 타이머 이벤트까지 남은 마이크로초를 반환.
        - processTimeEvents: 현재 시간에 발생해야 할 타이머 이벤트를 처리.

    	5. 이벤트 처리 메인 루프
        - aeProcessEvents: 주어진 이벤트 플래그에 따라 파일 및 타이머 이벤트를 처리.
        - aeWait: 주어진 파일 디스크립터가 지정된 이벤트 상태가 될 때까지 대기.
        - aeMain: 주 이벤트 루프 메서드로, 이벤트 처리를 계속 반복.

    	6. 이벤트 루프 실행
        - aeMain: 주 이벤트 루프를 실행. 루프를 멈추려면 aeStop을 호출.

    	7. 이벤트 루프 종료 및 정리
        - aeDeleteEventLoop: 이벤트 루프와 관련된 자원을 해제.

redis는 이벤트 루프를 비동기 병렬 처리 방식으로 작동한다. 비동기 병렬 처리는 여러 작업이 순차적으로 진행되는 것이 아니라 병렬적으로 진행되는 방식으로, 이전 작업이 요청 결과를 반환 하기까지 기다릴 필요없이 여러 작업을 동시에 처리 가능해 효율적이다.

2) 레디스 SET명령어 작동 과정
SET명령어는 레디스에서 사용되는 기본적인 명령어 중 하나로, 키-값 쌍을 저장하는 데 사용된다. 이 명령어는 주어진 키에 값을 할당하거나 설정하며 레디스의 데이터 저장및 관리를 위한 핵심적인 기능 중 하나이다. 주로 다음과 같은 기능을 수행한다.

	1. 값 할당 (Set Value) 
	특정 키에 값을 설정하거나 할당합니다. 예를 들어, SET mykey "Hello"는 "mykey"라는 키에 "Hello"라는 문자열 값을 할당한다.

	2. 키-값 쌍 저장 
	지정된 키와 값을 데이터베이스에 저장한다. 이 데이터는 메모리에 영구적으로 보존된다.

	3. 기존 값 덮어쓰기 
	이미 존재하는 키에 새로운 값을 설정하면 기존 값은 덮어쓴다. 이는 키가 이미 존재하는 경우 새로운 값을 할당할 때 발생한다.

	4.만료 시간 설정 
	추가적으로 옵션을 사용하여 값의 만료 시간을 설정할 수 있다. 예를 들어, SET mykey "Hello" EX 60은 "mykey"라는 키에 "Hello" 값을 할당하고,
 	이 값을 60초 후에 만료시킨다.

SET 명령어를 통해 값을 저장하는 과정은 아래의 단계로 구성된다.

	1. 클라이언트-서버 연결
	클라이언트가 redis-cli를 사용하여 서버에 접속한다. TCP/IP 소켓 연결을 통해 클라이언트와 서버 사이의 통신이 이루어진다.

	2. SET 명령어 전송
	클라이언트가 SET 명령어와 함께 key-value 쌍을 서버에 전송한다.

	3. 서버에서의 처리
	서버는 받은 SET 명령어를 처리한다. 데이터는 메모리 내의 키-값 구조로 저장된다.

	4. 사용되는 자료구조
	레디스는 간단한 키-값 저장소이지만 내부적으로 여러 자료구조를 사용한다. 주로 해시맵(Hash Map)을 사용하여 키와 값을 빠르게 검색하고 접근할 
	수 있도록 한다.

	여기서 해시맵이란, 해싱과 맵을 결합한 것으로 맵은 키-값의 쌍을 이루는 자료구조, 해싱은 키 값에 산술적인 연산을 적용해 찾고자 하는 자료에 
	접근하는 방법을 뜻한다. 즉, 자료 탐색시 키를 입력 받아 해싱 함수를 통해 해시 주소를 생성하고 이 해시 주소를 맵의 인덱스로 사용하는 탐색 기법이 
	해시맵인 것이다.

	5. 값의 저장 형식
	값은 일반적으로 문자열, 숫자, 리스트, 해시, 세트, 정렬된 세트 등 다양한 데이터 타입으로 저장될 수 있다. 이러한 데이터는 이진 안전 문자열로 
	저장되며, 이는 클라이언트가 전송한 데이터 형식을 유지하면서 서버에 저장된다. 

3) pang명령어 추가
레디스에 직접적으로 명령어를 추가하는 기능은 없다. 그러나 레디스는 EVAL 명령어를 통해 Lua형식의 스크립트를 실행하는 것이 가능하므로, 이를 이용해 pang을 입력하면 PUNG을 반환하도록 하는 스크립트를 만들어 레디스에서 실행하는 방법으로 기능을 구현해볼 수는 있다.

아래와 같이 pangCmd.lua 스크립트를 만든다

if ARGV[1] == "pang" then
	return "PUNG"
else
	return "Invalid Command"
end

이 스크립트는 EVAL 명령어로 받은 문자열이 pang이면 PUNG을, 그렇지 않으면 Invalid Command를 반환하도록 하는 명령이다.
이 스크립트를 실행하려면 터미널에 아래의 명령어를 입력한다.

$ redis-cli EVAL "$(cat pangCmd.lua)" 0 pang

0은 키값이 없음을 의미한다. 이 명령어를 실행하면 아래와 같은 결과가 나온다

"PUNG" 
